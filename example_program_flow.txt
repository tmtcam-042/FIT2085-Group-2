Example program flow pseudocode based off assignment specifications.
Note from ed forums: never, ever set or obtain values directly, only ever use getter/mutator functions. Will lose marks.
Okay strictly in method-to-method calls within one class. Not okay if ever accessed by an external function.

for 'SET MODE' BATTLE
main():
    b = Battle(Ash, Gary) # Initialisation of app. Only thing passed are names. Creates two empty team instances and sets self.battle_mode to None
    b.set_mode_battle()
    exit()



b.set_mode_battle flow looks like:
    b.set_battle_mode(0) # 0 == set mode (these names suck, confusing)
    team1.set_battle_mode(b.get_battle_mode) # Assigning battle mode 0 to both teams (yes this assigns 0 when it's already default 0, good practice)
    team2.set_battle_mode(b.get_battle_mode)

    for each team:
        team.choose_team(team1.get_battle_mode, None) # criterion field is None unless battle_mode == 2.
            <
            Choose_team is the *only* user input prompt I can find in the whole app.
            asks user input in form of C, B, S etc stuff. Stores into b.team1 or b.team2 etc
            choose_team then *calls* assign_team(C, B, S) for the given team

                <assign_team flow:
                Checks battle_mode to decide ADT to use.
                Assigns given C, B and S numbers into that ADT. Current implementation is Stack, should have support
                for three ADTs by assignment completion.
                >

            >

    Outside of for loop. Now, valid teams have been assigned into the corresponding ADT for this battle mode.
    It's battle time! Full battle functionality is contained within set_mode_battle.
    POSSIBLE DESIGN CHOICE: build separate function in Battle class for pokemon matchups? Once the battle mode
    ADT sets two pokemon against each other, the algorithm for their fight is always the same and
    therefore could be made into a repeatedly called method for readability.
    PRINT RESULTS OF MATCHUPS AS YOU GO

    for each matchup:
        If P1 speed > P2 speed:
            P1 strikes! Reduce P2 health by result of P2.calculate_damage_taken(P1)
            Check for P2 condition. Is P2.hp > 0?
                yes: goto P2 strikes back
                no: P2 removed from team, P1 gains 1 level and returns to its team. Print outcome.
        Else if P2 speed > P1 speed:
            P2 strikes! Reduce P1 health by result of P1.calculate_damage_taken(P2)
            Check for P1 condition. Is P1.hp > 0?
                yes: goto P1 strikes back
                no: P1 removed from team, P2 gains 1 level and returns to its team. Print outcome.
        Else (equal speeds):
            both strike! Reduce P1 and P2 health by result of Px.calculate_damage_taken(Py) respectively
            Check conditions. Are both alive?
                yes: Both lose 1 hp. Are both alive?:
                    yes: both return to teams. Print outcome.
                    no: surviving pokemon (if any) gains a level and returns to team. If no survivors, remove both from teams. Print outcome.
                no: surviving pokemon gains a level and returns to team. Print outcome.

        loop until one team's length = 0. If both teams length = 0 at that point, Draw. Else, team with pokemon wins! Print winner.



    example fight function below. fight is called after ADTs determine the matchup. Passed two Pokemon objects. Print statements not included
    def fight(P1: Pokemon, P2: Pokemon):
        If P1.get_speed() > P2.get_speed(): # P1 fights P2 first, then P2 has chance to retaliate.
            P2.set_hp(P2.get_hp() - P2.calculate_damage_taken(P1))
            If P2.get_hp() > 0:
                P1.set_hp(P1.get_hp() - P1.calculate_damage_taken(P2))
            Else:
                # P2 removed from team. Don't know what this implementation looks like
                P1.set_level(P1.get_level() + 1)
                # P1 returned to team. Don't know what this implementation looks like

        Else if P1.get_speed() < P2.get_speed(): # P2 fights P1 first, then P1 has chance to retaliate.
            P1.set_hp(P1.get_hp() - P1.calculate_damage_taken(P2))
            If P1.get_hp() > 0:
                P2.set_hp(P2.get_hp() - P2.calculate_damage_taken(P1))
            Else:
                # P1 removed from team. Don't know what this implementation looks like
                P2.set_level(P2.get_level() + 1)
                # P2 returned to team. Don't know what this implementation looks like

        Else: # Both fight at same time!
            P1.set_hp(P1.get_hp() - P1.calculate_damage_taken(P2)) # P1 takes damage
            P2.set_hp(P2.get_hp() - P2.calculate_damage_taken(P1)) # P2 takes damage
            # Check conditions.
            If P1.get_hp() > 0 && P2.get_hp() > 0: # Did both survive mutual clash
                P1.set_hp(P1.get_hp - 1) # Both lose 1 hp for the sin of surviving
                P2.set_hp(P2.get_hp - 1)
                If P1.get_hp() > 0 && P2.get_hp() > 0:
                    # Both returned to teams. Don't know what this implementation looks like.
                Else if P1.get_hp() > 0:
                    # P2 removed from team. Don't know what this implementation looks like.
                    P1.set_level(P1.get_level() + 1)
                    # P1 returned to team. Don't know what this implementation looks like.
                Else:
                    # P1 removed from team.
                    P2.set_level(P2.get_level() + 1)
                    # P2 returned to team.

            Else if P1.get_hp() > 0: # P1 lived and P2 didn't
                    # P2 removed from team. Don't know what this implementation looks like.
                    P1.set_level(P1.get_level() + 1)
                    # P1 returned to team. Don't know what this implementation looks like.
            Else:  # P2 lived and P1 didn't
                # P1 removed from team.
                P2.set_level(P2.get_level() + 1)
                # P2 returned to team.
